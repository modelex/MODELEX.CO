"0","X = matrix( "
"0","  c(0, 0, 1, "
"0","    0, 1, 1, "
"0","    1, 0, 1, "
"0","    1, 1, 1),"
"0","  nrow  = 4,"
"0","  ncol  = 3,"
"0","  byrow = TRUE"
"0",")"
"0",""
"0","# output dataset            "
"0","y = c(0, 0, 1, 1)"
"0",""
"0","# seed random numbers to make calculation"
"0","# deterministic (just a good practice)"
"0","set.seed(1)"
"0",""
"0","# initialize weights randomly with mean 0"
"0","synapse_0 = matrix(runif(3, min = -1, max = 1), 3, 1)"
"0",""
"0","# sigmoid function"
"0","nonlin <- function(x, deriv = FALSE) {"
"0","  if (deriv)"
"0","    x * (1 - x)"
"0","  else"
"0","    plogis(x)"
"0","}"
"0",""
"0",""
"0","nn_1 <- function(X, y, synapse_0, maxiter = 10000) {"
"0","  "
"0","  for (iter in 1:maxiter) {"
"0","  "
"0","      # forward propagation"
"0","      layer_0 = X"
"0","      layer_1 = nonlin(layer_0 %*% synapse_0)"
"0","  "
"0","      # how much did we miss?"
"0","      layer_1_error = y - layer_1"
"0","  "
"0","      # multiply how much we missed by the "
"0","      # slope of the sigmoid at the values in layer_1"
"0","      l1_delta = layer_1_error * nonlin(layer_1, deriv = TRUE)"
"0","  "
"0","      # update weights"
"0","      synapse_0 = synapse_0 + crossprod(layer_0, l1_delta)"
"0","  }"
"0","  "
"0","  list(layer_1 = layer_1, layer_1_error = layer_1_error, synapse_0 = synapse_0)"
"0","}"
"0",""
"0","fit_nn = nn_1(X, y, synapse_0)"
"0",""
"0","message(""Output After Training: \n"", "
"0","        paste0(capture.output(cbind(fit_nn$layer_1, y)), collapse = '\n'))"
"2","Output After Training: 
                 y
[1,] 0.009670417 0
[2,] 0.007864211 0
[3,] 0.993590571 1
[4,] 0.992115835 1
"
